const path = require("path");
const fs = require("fs").promises;
const yaml = require("js-yaml");
const minimist = require("minimist");
const prettier = require("prettier");
const util = require("util");
const exec = util.promisify(require("child_process").exec);

// tslint:disable:no-console CLI tools need to produce output

async function main() {
  const flags = minimist(process.argv.slice(2));
  // tslint:disable-next-line:no-string-literal CLI flags become confusing
  if (flags["h"] || flags["help"] || flags["_"].length < 1) {
    return showHelp();
  }

  // tslint:disable-next-line:no-string-literal CLI flags become confusing
  const ps = flags["_"].map(async file => {
    const { dirname, extension, basename } = dissectPath(file);
    const buffer = await fs.readFile(file);
    const fsm = yaml.safeLoadAll(buffer.toString());
    if (shouldGenerateCode(flags)) {
      const outfile = fsm.map(document => document.output_file).find(id => id);
      const varname = fsm.map(document => document.fsm_variable).find(id => id);
      console.log(`Generating ${outfile}`);
      const preamble = `
        /**
         * This file was generated by \`fsm-generator\` from ${basename}${extension}.
         */
      `;
      const code = preamble + (await generateCode(fsm, varname));
      const prettyCode = prettier.format(code, { parser: "typescript" });
      await fs.writeFile(path.join(dirname, outfile), prettyCode);
    }
    if (shouldGenerateGraph(flags)) {
      const dotfile = path.join(dirname, `${basename}.dot`);
      const svgfile = path.join(dirname, `${basename}.svg`);
      console.log(`Generating ${dotfile}`);
      const graph = await generateGraph(fsm);
      await fs.writeFile(dotfile, graph);
      console.log(`Generating ${svgfile}`);
      await exec(`dot -Tsvg ${dotfile} -o ${svgfile}`);
      if (!shouldKeepDotFile(flags)) {
        await fs.unlink(dotfile);
      }
    }
  });
  await Promise.all(ps);
}
main().catch(err => console.error(err));

async function generateGraph(fsm) {
  let file = `
  digraph G {
    node [shape=box];
  `;
  const document = { ...defaultDocument };
  for (const d of fsm) {
    if (typeof d === "string") {
      continue;
    }
    Object.assign(document, d);
  }
  const nodes = new Set(Array.from(document.nodes));
  for (const node of nodes) {
    file += `
      ${sanitizeNodeName(node.name)} [label="${node.name}"];
    `;
  }
  for (const transition of document.transitions) {
    file += `
      ${sanitizeNodeName(transition.origin)} -> ${sanitizeNodeName(
      transition.target
    )} [label="${edgeLabel(transition)}"];
    `;
  }
  file += `
  }
  `;
  return file;
}

function sanitizeNodeName(name) {
  return name.replace(/[^a-zA-Z0-9]/g, "_");
}

function edgeLabel(transition) {
  let label = `${transition.trigger}`;
  if (transition.guards && transition.guards.length > 0) {
    label += ` [${transition.guards.join(",")}]`;
  }
  if (transition.effects && transition.effects.length > 0) {
    label += ` /${transition.effects.join(" ")}`;
  }
  return label;
}

const defaultDocument = {
  nodes: [],
  transitions: [],
  triggers: []
};

function triggerName(trigger) {
  if (["AnyTrigger", "NoTrigger"].includes(trigger)) {
    return trigger;
  }
  return `Trigger.${trigger}`;
}

function nodeName(node) {
  if (["AnyNode", "Loopback"].includes(node)) {
    return node;
  }
  return `Node.${node}`;
}

async function generateCode(fsm, varname) {
  let file = "";
  for (let document of fsm) {
    if (typeof document === "string") {
      file += document;
    } else {
      document = { ...defaultDocument, ...document };
      document.triggers = document.triggers.filter(
        trigger => trigger.name !== "AnyTrigger"
      );
      document.nodes = document.nodes.filter(
        node => !["AnyNode", "Loopback"].includes(node.name)
      );
      if (document.nodes.length > 0) {
        file += `
          export enum Node {
            ${document.nodes.map(node => node.name).join(",")}
          }
        `;
      }
      if (document.triggers.length > 0) {
        file += `
          export enum Trigger {
            ${document.triggers.map(trigger => trigger.name).join(",")}
          }
        `;
      }

      for (const trigger of document.triggers) {
        file += `
          export interface ${trigger.name}Payload {
            ${Object.entries(trigger.payload || {})
              .map(entry => `${entry[0]}: ${entry[1]};`)
              .join("\n")}
          }
        `;
      }

      for (const transition of document.transitions) {
        file += `
          ${varname}.addTransition<${triggerName(transition.trigger)}>(
            ${nodeName(transition.origin)},
            ${triggerName(transition.trigger)},
            ${nodeName(transition.target)},
            {
              guards: ${renderTransformList(transition.guards)},
              effects: ${renderTransformList(transition.effects)},
            }
          );
        `;
      }
    }
  }

  const triggers = flatten(
    fsm
      .filter(
        document => typeof document === "object" && "triggers" in document
      )
      .map(document => document.triggers)
  );
  file += `
    export type TriggerPayload = ${triggers
      .map(trigger => `${trigger.name}Payload`)
      .join("|")};
    export interface TriggerPayloadMap {
      [NoTrigger]: {};
      ${triggers
        .map(trigger => {
          return `
            [Trigger.${trigger.name}]: ${trigger.name}Payload;
          `;
        })
        .join("\n")}
    }
  `;
  return file;
}

function renderTransformList(l) {
  if (!l || l.length <= 0) {
    return "[]";
  }
  return `[${l.join(",")}]`;
}

function dissectPath(file) {
  const dirname = path.dirname(file);
  const extension = path.extname(file);
  const basename = path.basename(file, extension);
  return { basename, extension, dirname };
}
function shouldGenerateCode(flags) {
  // tslint:disable-next-line:no-string-literal CLI flags become confusing
  return flags["c"] || flags["code"];
}

function shouldGenerateGraph(flags) {
  // tslint:disable-next-line:no-string-literal CLI flags become confusing
  return flags["g"] || flags["graph"];
}

function shouldKeepDotFile(flags) {
  // tslint:disable-next-line:no-string-literal CLI flags become confusing
  return flags["d"] || flags["dot"];
}

function showHelp() {
  console.log(`
${process.argv[0]} ${process.argv[1]} [options] <input files...>

Options:
  -h, --hel   Show this help
  -c, --code  Generate code
  -g, --graph Generate graph
  -d, --dot   Keep dot file
  `);
}

function flatten(arr) {
  return Array.prototype.concat.apply([], arr);
}
