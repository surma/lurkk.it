/**
 * This file was generated by `fsm-generator` from spec.yaml.
 */
/**
 * @license
 * Copyright (c) 2018 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at
 * http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at
 * http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */

// Itâ€™s too hard to make generated code linter compliant
/* tslint:disable */

import * as Model from "../model/model.js";

import {
  Effect,
  Guard,
  not,
  NoTrigger
} from "westend/src/state-machine/state-machine.js";
import { StateMachine } from "westend/src/state-machine/state-machine.js";

const topViewPredicate = (
  f: (view: View) => boolean
): Guard<State, TriggerPayloadMap, DataObject> => {
  return (fsm, trigger, payload) => {
    if (fsm.data.stack.length <= 0) {
      return false;
    }
    return f(fsm.data.stack[fsm.data.stack.length - 1]);
  };
};

const isLoadRequestOfType = (
  lrt: LoadRequestType
): Guard<State, TriggerPayloadMap, DataObject> => {
  return (fsm, trigger, payload) =>
    !!fsm.data.loadRequest && fsm.data.loadRequest.type === lrt;
};

const storeLoadRequest: Effect<State, TriggerPayloadMap, DataObject> = async (
  fsm,
  trigger,
  payload
) => {
  fsm.data.loadRequest = payload.loadRequest;
};

const loadThread: Effect<State, TriggerPayloadMap, DataObject> = async (
  fsm,
  trigger,
  payload
) => {
  const loadRequest = fsm.data.loadRequest;
  if (!loadRequest || loadRequest.type !== LoadRequestType.THREAD) {
    throw new Error("loadRequest is not of type THREAD");
  }

  // Run this code concurrently to the state machine
  Promise.resolve().then(async () => {
    const [thread, comments] = await Model.loadThread(loadRequest.id);
    fsm.data.stack.push({
      view: ViewType.THREAD,
      thread,
      comments
    });
    delete fsm.data.loadRequest;
    fsm.emitTrigger(Trigger.LOADING_DONE);
  });
};

const loadSubreddit: Effect<State, TriggerPayloadMap, DataObject> = async (
  fsm,
  trigger,
  payload
) => {
  const loadRequest = fsm.data.loadRequest;
  if (!loadRequest || loadRequest.type !== LoadRequestType.SUBREDDIT) {
    throw new Error("loadRequest is not of type SUBREDIT");
  }

  // Run this code concurently to the state machien
  Promise.resolve().then(async () => {
    const subreddit = await Model.loadSubreddit(loadRequest.id);
    fsm.data.stack.push({
      view: ViewType.SUBREDDIT,
      subreddit
    });
    delete fsm.data.loadRequest;
    fsm.emitTrigger(Trigger.LOADING_DONE);
  });
};

export enum State {
  INIT,
  RECOVER,
  DISPATCH,
  LOAD,
  SUBREDDIT,
  THREAD
}

export enum Trigger {
  LOAD_REQUEST,
  LOADING_DONE
}

export interface LOAD_REQUESTPayload {
  trigger: Trigger.LOAD_REQUEST;
  loadRequest: LoadRequest;
}

export interface LOADING_DONEPayload {
  trigger: Trigger.LOADING_DONE;
}
export enum ViewType {
  SUBREDDIT,
  THREAD,
  EMPTY
}

export interface SubredditView {
  view: ViewType.SUBREDDIT;
  subreddit: Model.Subreddit;
}

export interface ThreadView {
  view: ViewType.THREAD;
  thread: Model.Thread;
  comments: Model.Comment[];
}

export interface EmptyView {
  view: ViewType.EMPTY;
}

export type View = SubredditView | ThreadView | EmptyView;

export enum LoadRequestType {
  SUBREDDIT,
  THREAD
}

export interface SubredditLoadRequest {
  type: LoadRequestType.SUBREDDIT;
  id: Model.SubredditID;
}

export interface ThreadLoadRequest {
  type: LoadRequestType.THREAD;
  id: Model.ThreadID;
}

export type LoadRequest = SubredditLoadRequest | ThreadLoadRequest;

export interface DataObject {
  loadRequest?: LoadRequest;
  stack: View[];
}

export const fsm = new StateMachine<State, TriggerPayloadMap, DataObject>(
  State.INIT,
  {
    stack: []
  }
);

fsm.addTransition(State.INIT, Trigger.LOAD_REQUEST, State.DISPATCH, {
  guards: [],
  effects: [storeLoadRequest]
});

fsm.addTransition(State.DISPATCH, NoTrigger, State.LOAD, {
  guards: [isLoadRequestOfType(LoadRequestType.SUBREDDIT)],
  effects: [loadSubreddit]
});

fsm.addTransition(State.DISPATCH, NoTrigger, State.LOAD, {
  guards: [isLoadRequestOfType(LoadRequestType.THREAD)],
  effects: [loadThread]
});

fsm.addTransition(State.LOAD, Trigger.LOADING_DONE, State.SUBREDDIT, {
  guards: [topViewPredicate(view => view.view === ViewType.SUBREDDIT)],
  effects: []
});

fsm.addTransition(State.LOAD, Trigger.LOADING_DONE, State.THREAD, {
  guards: [topViewPredicate(view => view.view === ViewType.THREAD)],
  effects: []
});

fsm.addTransition(State.THREAD, Trigger.LOAD_REQUEST, State.DISPATCH, {
  guards: [],
  effects: [storeLoadRequest]
});

fsm.addTransition(State.SUBREDDIT, Trigger.LOAD_REQUEST, State.DISPATCH, {
  guards: [],
  effects: [storeLoadRequest]
});

export type TriggerPayload = LOAD_REQUESTPayload | LOADING_DONEPayload;
export interface TriggerPayloadMap {
  [Trigger.LOAD_REQUEST]: LOAD_REQUESTPayload;

  [Trigger.LOADING_DONE]: LOADING_DONEPayload;
}
