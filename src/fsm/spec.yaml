--- |
  /**
   * @license
   * Copyright (c) 2018 The Polymer Project Authors. All rights reserved.
   * This code may only be used under the BSD style license found at
   * http://polymer.github.io/LICENSE.txt
   * The complete set of authors may be found at
   * http://polymer.github.io/AUTHORS.txt
   * The complete set of contributors may be found at
   * http://polymer.github.io/CONTRIBUTORS.txt
   * Code distributed by Google as part of the polymer project is also
   * subject to an additional IP rights grant found at
   * http://polymer.github.io/PATENTS.txt
   */

  // Itâ€™s too hard to make generated code linter compliant
  /* tslint:disable */

  import { Subreddit, SubredditID } from "../model/subreddit.js";
  import { Thread, ThreadID } from "../model/thread.js";
  import { View, ViewType } from "../model/view.js";
  import * as Model from "../model/model.js";

  import {
    AnyNode,
    Effect,
    Guard,
    Loopback,
    not,
    NoTrigger,
    StateMachine,
    State
  } from "westend/src/state-machine/state-machine.js";

  function genUid() {
    let uid = "";
    for (let i = 0; i < 16; i++) {
      uid += String.fromCharCode(Math.floor(97 + Math.random() * 26));
    }

    return uid;
  }

---
fsm_variable: fsm
output_file: generated.ts
nodes:
  - name: STACK_VIEW

triggers:
  - name: VIEW_SUBREDDIT
    payload:
      id: SubredditID
  - name: VIEW_THREAD
    payload:
      id: ThreadID
  - name: DISMISS
  - name: REFRESH

--- |
  export type LoadingEntry = string;

  export interface Value {
    loading: LoadingEntry[];
    favorites: SubredditID[];
    stack: View[];
  }

  export const fsm = new StateMachine<Node, TriggerPayloadMap, Value>(
    Node.STACK_VIEW,
    {
      loading: [],
      favorites: [],
      stack: [],
    }
  );

  function showLoadingBar(fsm: StateMachine<Node, TriggerPayloadMap, Value>, loadingEntry: LoadingEntry) {
    const value = fsm.value;
    value.loading.push(loadingEntry);
    fsm.setValue(value);
  }

  function hideLoadingBar(fsm: StateMachine<Node, TriggerPayloadMap, Value>, loadingEntry: LoadingEntry) {
    const value = fsm.value;
    value.loading = value.loading.filter(f => f !== loadingEntry);
    fsm.setValue(value);
  }

  const loadThread: Effect<Node, Trigger.VIEW_THREAD, TriggerPayloadMap, Value> = async (fsm, trigger, payload) => {
    showLoadingBar(fsm, payload.id);
    const [thread, comments] = await Model.loadThread(payload.id);
    fsm.value.stack.push({
      type: ViewType.THREAD,
      uid: genUid(),
      thread,
      comments
    });
    hideLoadingBar(fsm, payload.id);
  }

  const loadSubreddit: Effect<Node, Trigger.VIEW_SUBREDDIT, TriggerPayloadMap, Value> = async (fsm, trigger, payload) => {
    showLoadingBar(fsm, payload.id);
    const subreddit = await Model.loadSubreddit(payload.id);
    fsm.value.stack.push({
      type: ViewType.SUBREDDIT,
      uid: genUid(),
      subreddit
    });
    hideLoadingBar(fsm, payload.id);
  }

  const dismiss: Effect<Node, Trigger.DISMISS, TriggerPayloadMap, Value> = async (fsm, trigger, payload) => {
    fsm.value.stack.pop();
  }

  const refresh: Effect<Node, Trigger.REFRESH, TriggerPayloadMap, Value> = async (fsm, trigger, payload) => {
    if(fsm.value.stack.length <= 0) {
      return;
    }
    showLoadingBar(fsm, "refresh");
    const topView = fsm.value.stack.pop()!;
    fsm.setValue(fsm.value);
    let id;
    switch(topView.type) {
      case ViewType.THREAD:
        id = topView.thread.id;
        await Model.refreshThread(id);
        fsm.emitTrigger<Trigger.VIEW_THREAD>(
          Trigger.VIEW_THREAD,
          { id }
        );
        break;
      case ViewType.SUBREDDIT:
        id = topView.subreddit.id;
        await Model.refreshSubreddit(id);
        fsm.emitTrigger<Trigger.VIEW_SUBREDDIT>(
          Trigger.VIEW_SUBREDDIT,
          { id }
        );
        break;
    }
    hideLoadingBar(fsm, "refresh");
  }
---
transitions:
  - origin: STACK_VIEW
    trigger: VIEW_SUBREDDIT
    target: STACK_VIEW
    effects: [loadSubreddit]
  - origin: STACK_VIEW
    trigger: VIEW_THREAD
    target: STACK_VIEW
    effects: [loadThread]
  - origin: AnyNode
    trigger: DISMISS
    target: Loopback
    effects: [dismiss]
  - origin: AnyNode
    trigger: REFRESH
    target: Loopback
    effects: [refresh]

--- |
  export const READY_CHANNEL = "fsm.ready";
