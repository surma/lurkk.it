--- |
  /**
   * @license
   * Copyright (c) 2018 The Polymer Project Authors. All rights reserved.
   * This code may only be used under the BSD style license found at
   * http://polymer.github.io/LICENSE.txt
   * The complete set of authors may be found at
   * http://polymer.github.io/AUTHORS.txt
   * The complete set of contributors may be found at
   * http://polymer.github.io/CONTRIBUTORS.txt
   * Code distributed by Google as part of the polymer project is also
   * subject to an additional IP rights grant found at
   * http://polymer.github.io/PATENTS.txt
   */

  // Itâ€™s too hard to make generated code linter compliant
  /* tslint:disable */

  import { Subreddit, SubredditID } from "../model/subreddit.js";
  import { Thread, ThreadID } from "../model/thread.js";
  import { View, ViewType } from "../model/view.js";
  import * as Model from "../model/model.js";

  import {
    Effect,
    Guard,
    not,
    NoTrigger,
    StateMachine,
    State 
  } from "westend/src/state-machine/state-machine.js";

  function genUid() {
    let uid = "";
    for (let i = 0; i < 16; i++) {
      uid += String.fromCharCode(Math.floor(97 + Math.random() * 26));
    }

    return uid;
  }

---
fsm_variable: fsm
output_file: generated.ts
nodes:
  - name: STACK_VIEW

triggers:
  - name: VIEW_SUBREDDIT
    payload:
      id: SubredditID
  - name: VIEW_THREAD
    payload:
      id: ThreadID
  - name: DISMISS

--- |
  export enum LoadingType {
    VIEW,
    DOWNLOAD
  }

  export interface Value {
    loading: LoadingType[];
    favorites: SubredditID[];
    stack: View[];
  }

  export const fsm = new StateMachine<Node, TriggerPayloadMap, Value>(
    Node.STACK_VIEW,
    {
      loading: [],
      favorites: [],
      stack: [],
    }
  );

  type LoadingTriggers = Trigger.VIEW_SUBREDDIT | Trigger.VIEW_THREAD;
  function loadingEffect(
      type: LoadingType,
      effect: Effect<Node, LoadingTriggers, TriggerPayloadMap, Value>
  ): Effect<Node, LoadingTriggers, TriggerPayloadMap, Value> {
    return async function(fsm, trigger, payload) {
      let value = fsm.value;
      value.loading.push(type);
      fsm.setValue(value);
      await effect(fsm, trigger, payload);
      value = fsm.value;
      value.loading = value.loading.filter(f => f !== type);
      fsm.setValue(value);
    }
  }

  const loadThread: Effect<Node, LoadingTriggers, TriggerPayloadMap, Value> = async (fsm, trigger, payload) => {
    if(trigger !== Trigger.VIEW_THREAD) {
      throw new Error("Invalid trigger to load a thread");
    }
    const [thread, comments] = await Model.loadThread(payload.id);
    fsm.value.stack.push({
      type: ViewType.THREAD,
      uid: genUid(),
      thread,
      comments
    });
  }

  const loadSubreddit: Effect<Node, LoadingTriggers, TriggerPayloadMap, Value> = async (fsm, trigger, payload) => {
    if(trigger !== Trigger.VIEW_SUBREDDIT) {
      throw new Error("Invalid trigger to load a thread");
    }
    const subreddit = await Model.loadSubreddit(payload.id);
    fsm.value.stack.push({
      type: ViewType.SUBREDDIT,
      uid: genUid(),
      subreddit
    });
  }

---
transitions:
  - origin: STACK_VIEW
    trigger: VIEW_SUBREDDIT
    target: STACK_VIEW
    effects: [loadingEffect(LoadingType.VIEW, loadSubreddit)]
  - origin: STACK_VIEW
    trigger: VIEW_THREAD
    target: STACK_VIEW
    effects: [loadingEffect(LoadingType.VIEW, loadThread)]

--- |
  export const READY_CHANNEL = "fsm.ready";
